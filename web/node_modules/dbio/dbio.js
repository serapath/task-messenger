;(function dat_container_runtime () { // [initial version: 2024.05.18]
  // ----------------------------------------------------------------------------
  module.exports = shim
  // ----------------------------------------------------------------------------
  async function shim (REGISTRY, PROGRAMS) { // v2024.05.27
    validize_args(REGISTRY, PROGRAMS)
    const run = window !== top ? container : dbio
    run(REGISTRY, PROGRAMS)
  }
  // ----------------------------------------------------------------------------
  function validize_args (REGISTRY = {}, PROGRAMS = {}) { // v2024.05.27
    // @TODO: upgrade later to proper persistent registry
    Object.assign(REGISTRY, { '': [() => {}, internal_vault] }, REGISTRY)
    const stack = [{ path: [], level: PROGRAMS }]
    while (stack.length) {
      const { path, level } = stack.pop()
      if (!level['']) level[''] = ''
      const keys = Object.keys(level)
      for (var i = keys.length; i--;) {
        const k = keys[i]
        path.push(k)
        const v = level[k]
        if (typeof v === 'string') {
          const M = REGISTRY[v]
          if (!Array.isArray(M)) throw new Error(`module "${v}" is undefined`)
          const [require, exports] = M
          if (typeof require !== 'function') throw new Error(`module "${v}" at "${path}" is ill defined`)
          if (typeof exports !== 'function') throw new Error(`module "${v}" at "${path}" is ill defined`)
        } else {
          if (v !== Object(v)) throw new Error(`PROGRAMS is ill defined in "${path}"`)
          stack.push({ path: [...path], level: v })
        }
        path.pop()
      }
    }
  }
  // ----------------------------------------------------------------------------
  async function container (REGISTRY, PROGRAMS) { // v2024.05.30
    // launched from BOOTLOADER
    const fragment = location.hash.slice(1)


    const command = cmd_codec.decode(fragment) // @TODO: what if fragment is only a single string?


    if ('' in command) {
      const vault_app = command['']
      const label = vault_app || '(vault)'
      alert(`%c[${label.toUpperCase()}]`, 'color: skyblue;', 'run')
      delete command['']
      const [require, launch] = REGISTRY[vault_app]
      const port = window.port
      delete window.port
      port.onmessage = onmessage
      window.node.require = use.bind(require)
      window.node.config = command
      window.name = `${label}`
      window.node.name = referrer
      const vault_window = {
        JSON: window.JSON,
        Object: window.Object,
        document: window.document,
        console: { log: console.log.bind(console) },
        cmd_codec,
        location: { hash: `#${cmd_codec.encode(command)}` },
        node,
        Error,
        Math,
        setInterval,
      }
      vault_window.window = vault_window
      const api = node.box(`(${launch})(window.node)`, vault_window)
      console.log(label, { api })
      return api
    } else {
      const command = fragment
      const [require, launch] = REGISTRY[command]

      const label = fragment
      const port = window.port
      delete window.port
      port.onmessage = onmessage
      window.node.require = use.bind(require)
      window.node.config = command
      window.name = `${label}`
      const app_window = {
        JSON: window.JSON,
        Object: window.Object,
        document: window.document,
        console: { log: console.log.bind(console) },
        cmd_codec,
        location: { hash: `#${cmd_codec.encode(command)}` },
        node,
        Error,
        Math,
        setInterval,
        // iframer,
      }
      app_window.window = app_window
      const api = node.box(`(${launch})(window.node)`, app_window)
      console.log(label, { api })
      function onmessage (event) {
        alert(`%c[${fragment.toUpperCase()}]`, 'color: green;', '[from vault]', evemt)
        const { type } = event.data || {}
        if (!api[type]) console.error('ERROR:', window.name, 'does not support', type)
      }

    }
    function use (name) {
      const require = this
      console.log('[require]', name)
      const [subrequire, launch] = require(name)
      return launch({ require: use.bind(subrequire) })
    }
    function onmessage (event) {
      alert(`%c[${program.toUpperCase()}]`, 'color: skyblue;', '[from bootloader]', evemt)
      const { type } = event.data || {}
      if (!api[type]) console.error('ERROR:', window.name, 'does not support', type)
    }
  }
  // demo(taskmessenger(ana,bob),devenv(ana,bob))
  // ----------------------------------------------------------------------------
  async function dbio (REGISTRY, PROGRAMS) { // v2024.05.27
    const daturn_armed_turtle_shell = `ü™êüöÄ<span style="transform: scale(-1, 1);">üê¢</span>`
    const info = `dbio shim: [v0.0.1-pre-alpha-rc.1] ${daturn_armed_turtle_shell} dat(a container runtime)`
    const on = {}
    const txt = Object.assign(document.createElement('div'), { innerHTML: info} ).textContent
    console.log(`%c${txt}`, 'color: gray;')
    window.name = '(dbio)'
    window.fetch = window.fetch.bind(window)
    window.addEventListener = window.addEventListener.bind(window)
    window.removeEventListener = window.removeEventListener.bind(window)
    // -----------------
    window.spawn = spawn
    window.tasks = {}
    window.counter = 0
    window.validize_args = validize_args
    window.cmd_codec = { encode, decode }
    // const location = window.location
    // window.location = new Proxy({}, {
    //   get (o, k) { return o[k] },
    //   set (o, k, v) {
    //     console.log({k, o, loc: location[k]})
    //     if (k === 'hash') try { return o[k] = location[k] = v} finally { on.hashchange(new HashChangeEvent('hashchange')) }
    //     else return o[k] = location[k] = v
    //   },
    // }),
    const vault = document.createElement('div')
    document.body.append(vault)
    vault.style = 'flex-grow: 1;'
    const kernel = Object.assign(document.createElement('div'), {
      innerHTML: info,
      style: `line-height: 14px; display: flex; align-items: center;
      justify-content: center; font-size: 9px; font-weight: 900;`
    })
    document.body.append(kernel)
    window.shadow = vault.attachShadow({ mode: 'closed' })
    Object.defineProperty(window, 'onhashchange',  {
      get () { return on.hashchange },
      set (v) { return on.hashchange = v }
    })
    const source = `return (Reg, Ps) => (${dbio_loader})(Reg, Ps)`
    const F = await box(source, window)
    await F(REGISTRY, PROGRAMS)
  }
  // ----------------------------------------------------------------------------
  async function dbio_loader (REGISTRY, PROGRAMS) { // v2024.05.27
    const randomHsl = () => `hsla(${Math.random() * 360}, 100%, 25%, 1)`
    // const c = randomHsl()
    const c = `hsla(133, 57%, 45%, 1);`
    document.body.style = `box-sizing: border-box; margin: 0;
    display: flex; flex-direction: column; height: 100vh;
    background-color: ${c}; color: white; font-family: Courier New; padding: 0px;`
    document.title = `[ü™ê] `
    const { href, hash } = new URL(document.currentScript.src)
    // @TODO: use # everything for now -> but later history push state to adjust query too
    // const default_commands = cmd_codec.decode(hash.slice(1)) // @TODO: use url params
    const default_programs = cmd_codec.encode(PROGRAMS)
    const bundle = await (await fetch(href)).text()
    window.__temp__ = { bundle }
    // @TODO: verify all params if they exist, otherwise start only default vault and show recover options
    oncommand()
    function oncommand (event) {
      localStorage.clear()
      // @TODO: use # everything for now -> but later history push state to adjust query too
      const fragment = decodeURIComponent(location.hash.slice(1))
      const hash = !event ? fragment || localStorage.autostart : fragment
      const cmds = Object.assign({ '': '' }, cmd_codec.decode(hash || default_programs))
      if (!(cmds[''] in PROGRAMS)) {
        console.error(`"${vault}" not found.`)
        cmds[''] = ''
      }
      window.onhashchange = undefined
      const programs = cmd_codec.encode(cmds)
      location.hash = localStorage.autostart = programs
      window.onhashchange = oncommand
      console.log('%c[DBIO]', 'color:green;', event ? 'reboot' : 'boot', cmds)
      const [vault, ...tools] = Object.keys(cmds).map(x => x || '(vault)')
      document.title = `[ü™ê] ` + vault + ' : ' + tools
      const id = counter++
      // @INFO: build task (=iframe task) (= itask)
      console.error(cmds)
      shadow.append(spawn(cmds[''] || '(root)', cmds, port => {
        port.onmessage = onmessage
        tasks[id] = port
      }))
      function onmessage ({ data, ports: [port] }) {
        console.log(`%c[DBIO]%c[by root] recv`, 'color:green;', 'color:white;', data, port)
        console.log('@TODO: set up sys api for program to interact with')
      }
    }
  }
  // ----------------------------------------------------------------------------
  // --------------------------------------------------------------------------
  function box (source, sdk = {}) { // v2024.05.22
    const name = sdk.name || '(anon)' // @TODO: increase counter maybe
    if (typeof source === 'function') source = `return (${source})()`
    Object.assign(sdk, { globalThis: sdk })
    sdk.require = null // @TODO: fix this
    sdk.top = null // @TODO: fix this
    const global = new Proxy(sdk, {
      get (sdk, k) {
        if (typeof k === 'string' && !(k in sdk)) throw new Error(`Uncaught ReferenceError: ${k} is not defined`)
        return sdk[k] === sdk ? global : sdk[k]
      },
      put (sdk, k, v) { return sdk[k] = v === sdk ? global : v },
      has () { return true },
      deleteProperty (sdk, k) { return delete sdk[k] },
      ownKeys(sdk) { return Object.keys(sdk) },
      isExtensible (sdk) { return Object.isExtensible(sdk) },
      setPrototypeOf (sdk, p) { return Reflect.setPrototypeOf(sdk, p) },
      getPrototypeOf (sdk) { return Reflect.getPrototypeOf(sdk) },
      // apply (sdk, self, args) { return Reflect.apply(sdk, sefl, args) },
      // construct (sdk, args, o) { return Reflect.construct(sdk, args, o) },
      defineProperty (sdk, k, descriptor) {
        Object.defineProperty(sdk, k, descriptor)
        return global
      },
      getOwnPropertyDescriptor (sdk, k) {
        return Object.getOwnPropertyDescriptor(sdk, k)
      },
      preventExtension (sdk) {
        Object.preventExtensions(sdk)
        return true
      },
    })
    const run = new Function('global', `//# sourceURL=${name}
    with (global) return (function () { "use strict";\n${source};\n})()`)
    return run(global)
  }
  // ----------------------------------------------------------------------------
  function encode (o) { // v2024.05.29
    o = Object.assign({}, o)
    Object.keys(o).map(k => { try { o[k] = JSON.stringify(o[k]) } catch (e) { } })
    const s = decodeURIComponent(new URLSearchParams(o).toString())
    return s
  }
  // ----------------------------------------------------------------------------
  function decode (s) { // v2024.05.29
    const o = Object.fromEntries(new URLSearchParams(s).entries())
    Object.keys(o).map(k => { try { o[k] = JSON.parse(o[k]) } catch (e) { } })
    return o
  }
  // ----------------------------------------------------------------------------
  // function add_deps (f, ...deps) { // v2024.05.26
  //   const bundle = `${f}`.slice(0, -1) + `${deps.map(dep => `${dep}\n`)}}`
  //   return bundle
  // }
  // ----------------------------------------------------------------------------
  function recover () { // v2024.05.27
    // window.onerror = recover // ???
    // @TODO: allow to reset location.hash and localStorage.autostart to defaults
    // @TODO: show meaningful error and maybe support chat buttons to get help
  }
  // ----------------------------------------------------------------------------
  // ----------------------------------------------------------------------------
  function spawn /* i-task */ (name, opts = {}, listen) { // v2024.05.30
    if (typeof opts === 'function') [opts, listen] = [{}, opts]
    return iframer(connect)
    // @TODO: spawn should auto append to an element in sys_sdk.document.body
    // -> which is empty, because instead it is fullscreen populated by noscript iframe
    function connect (iwindow) { // -> datauri bootloader iframe
      const filepath = name
      const { bundle } = window.__temp__
      const source = JSON.stringify(bundle)
      const program = cmd_codec.encode(opts)
      const loader = web_loader
      // -----------------------
      const myspawn = `${spawn}`.slice(0, -1) + `${web_loader}\n${BOOTLOADER}\n${box}\n}`
      const myloader = `${loader}`.slice(0, -1) + `${cmd_codec.decode}\n${cmd_codec.encode}\n}`
      const iframe_bootloader = `//# sourceURL=${filepath}\n//# ignoreList=${filepath}\n
      (${BOOTLOADER})((p => (event = void 0, p))(event.ports[0]),
      "${name}", ${JSON.stringify(opts)},
      ${myspawn}, ${box}, ${source}, '${program}', ${myloader}, ${cmd_codec.decode}, ${cmd_codec.encode}, ${iframer})`
      const { port1, port2 } = new MessageChannel()
      iwindow.postMessage(iframe_bootloader, '*', [port1])
      listen(port2)
      // -----------------------
    }
  }
  // ----------------------------------------------------------------------------
  function web_loader () { // v2024.05.23
    // e.g. for VAULT
    const cmd_codec = { encode, decode }
    if (window.name !== web_loader.name) throw new Error('web loader error')
    const { opts: command } = __temp__

    const vault_name = command[''] || '(vault)'

    // @TODO: what if command is only a single string?
    const fragment = typeof command === 'string' ? command : cmd_codec.encode(command)



    const name = vault_name
    console.log('%c[WEBLOADER]', 'color:green;', 'load', name, command)
    const on =  {}
    const app_sdk = make_app_sdk(window.iwindow)
    return app_sdk
    function make_app_sdk (window) {
      const {
        Promise, setTimeout, clearTimeout, document, console, Object,
        Blob, URL, Array, JSON, Math, setInterval
      } = window
      const si = (...args) => setInterval(...args)
      const sdk = { // @TODO: make this a true membrane!
        node: {},
        name: '(sudo)', // web_loader? // loader:web
        Promise,
        setTimeout,
        clearTimeout,
        document,
        console,
        Object,
        Blob,
        JSON,
        URL,
        Array,
        Math,
        setInterval: si,
        alert: console.log.bind(console),
        location: new Proxy({ hash: `#${fragment}` }, {
          get (o, k) { return o[k] },
          set (o, k, v) {
            try { return o[k] = v = `#${v}` } finally { on.hashchange?.(v) }
          },
        }),
        localStorage: { autostart: fragment },
      }
      Object.defineProperty(document, 'title',  {
        get () { return document.title },
        set (v) { return document.title = v }
      })
      Object.defineProperty(sdk, 'onhashchange',  {
        get () { return on.hashchange },
        set (v) { return on.hashchange = v }
      })
      sdk.window = sdk.globalThis = sdk
      return sdk
    }
  }
  // ----------------------------------------------------------------------------
  async function BOOTLOADER (port0, name, opts, spawn, box, bundle, program, loader, decode, encode, iframer) {  // v2024.05.30
    const cmd_codec = { encode, decode }
    console.log('%c[BOOTLOADER]', 'color:green;', 'loader:', loader.name, 'program:', name, opts)

    port0.onmessage = root_receive
    const { port1, port2 } = new MessageChannel()
    port1.onmessage = prog_receive

    // console.log('CHOOSE:', {name, opts}) // (root) // opts
    const args = (typeof opts === 'string') ? {} : opts



    const loader_sdk = await (('' in args) ? make_vault_sdk(window) : make_sys_sdk(window))
    // const loader_sdk = await make_sys_sdk(window)
    loader_sdk.port = port0
    loader_sdk.iframer = iframer
    loader_sdk.__temp__ = { bundle, opts }
    loader_sdk.cmd_codec = cmd_codec
    loader_sdk.name = loader.name
    loader_sdk.referrer = name



    const app_sdk = box(loader, safeguard(loader_sdk))
    app_sdk.node = { box, spawn }
    app_sdk.port = port2
    app_sdk.Error = Error
    app_sdk.cmd_codec = cmd_codec
    app_sdk.referrer = name

    // inside new iframe, BOOTLOADER box -> run bundle again to load "vault"
    const app_api = box(bundle, safeguard(app_sdk))



    // @TODO: maybe use `app_api`
    return
    function prog_receive (event) {
      console.log('%c[BOOTLOADER]', 'color:green;', `[from ${name}]`, event)
      port0.postMessage(event.data)
    }
    function root_receive (event) {
      console.log('%c[BOOTLOADER]', 'color:green;', '[from dbio]', event)
      const message = event.data
      const { type = '', data = [] } = message || {}
      port1.postMessage(message)
      if (app_api[type]) app_api(...data)
    }
    function safeguard (window) {
      // @TODO: secure window object
      // @TODO: try to re-use safemode()
      // console.error('@TODO: safeguard noscript document')
      // @TODO: safeguard: access through DOM of iframe realms:
      // -> Object, Object.prototype, Function, Function.prototype, Error, Error.prototype
      // possibly others
      // ==> scuttle and lock down iframe as well and replace with inert where possible
      return window
    }
    async function make_vault_sdk (window) {
      // @TODO: window.name = loader.name
      // @TODO: iwindow.name = app_name => name
      window.name = name
      window.iwindow = window
      return window
    }
    async function make_sys_sdk (window) { // -> sandboxed noscript iframe
      const el = iframer('allow-same-origin', iwindow => {
        iwindow.name = name // e.g. 'taskchat'
        window.iwindow = iwindow
        window.name = loader.name
        resolve(window)
      })
      document.body.append(el)
      document.body.style = `display: flex; margin: 0; height: 100vh;`
      const { resolve, promise } = Promise.withResolvers()
      return promise
    }

  }
  // ----------------------------------------------------------------------------
  function iframer (sandbox, done) { // v2024.05.30
    if (typeof sandbox === 'function') [sandbox, done] = ['', sandbox]
    const iframe = document.createElement('iframe')
    new Promise(f => iframe.onload = _ => f(iframe.contentWindow)).then(done)
    if (!sandbox) { // 1. datauri bootloader iframe
      const id = Math.random() // @TODO: use a id/counter from parent frame location.href?
      const T = 'script'
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"></head>${''
      }<body><${T}>document.currentScript.remove();onmessage=E=>eval(E.data)${''
      }//${id}</${T}></body></html>`
      const bytes = new TextEncoder().encode(html)
      const b64 = btoa(Array.from(bytes, b => String.fromCodePoint(b)).join(""))
      iframe.src = 'data:text/html;base64,' + b64 // data uri
      // const randomHsl = () => `hsla(${Math.random() * 360}, 100%, 65%, 1)`
      // const c = randomHsl()
      // iframe.style = `border: 1; width: 100%; height: 100%; display: grid;
      // box-sizing: border-box; background-color: ${c};`

      iframe.style = `border: 2px solid red; width: 100%;
      height: 100%;
      display: grid;
      box-sizing: border-box;`
      const el = document.createElement('div')
      el.style = `height: 100%;
      box-sizing: border-box;
      padding: 2px;
      background-color: #333;`
      const sh = el.attachShadow({ mode: 'closed' })
      sh.append(iframe)
      return el
    } else { // 2. sandboxed noscript iframe
      iframe.srcdoc = `<!DOCTYPE html>
      <html><head><meta charset="utf-8"></head><body></body></html>`
      iframe.sandbox = sandbox
      iframe.style = 'border: 0; margin: 0; padding: 0;  display: flex; flex-grow: 1'
      return iframe
    }
  }
  // ----------------------------------------------------------------------------
  async function internal_vault (node) { // v2024.05.30
    document.documentElement.style = `height: 100%; margin: 0; box-sizing: border-box;`
    document.body.style = `display: flex;
    flex-direction: column;
    flex-grow: 1;
    height: 100%;
    margin: 0;
    box-sizing: border-box;
    padding: 0;
}`
    const tasks = {}
    const fragment = location.hash.slice(1)
    const command = cmd_codec.decode(fragment)

    const icon_play = '‚ñ∂Ô∏è'
    const icon_stop = '‚èπ'
    const state = { program: {} }
    const { config, spawn } = node
    if (JSON.stringify(config) !== JSON.stringify(command)) throw new Error('wat?')
    const el = document.createElement('div')
    el.style = `display: flex;
    flex-direction: column;
    background-color: gray;
    box-sizing: border-box;
    height: 100%;`
    // üõ°Ô∏è
    el.innerHTML = `
    <div class="grid"></div>
    <div><label>üê¢ ${node.name} </label><span> ${
      Object.keys(command).map(name => {
      state.program[name] = 'idle'
      return `<button data-name="${name}"><span>${icon_play}</span>${name}</button>`
    }).join('')
    }</span></div>`
    const [grid, menu] = el.children
    menu.style = `background-color: gray`
    grid.style = `display: flex;
    flex-wrap: wrap;
    box-sizing: border-box;
    padding: 5px;
    flex-grow: 1;
    background-color: darkgray;`
    const items = [...el.querySelectorAll('button')]
    items.forEach(btn => btn.onclick = (navigate({
      preventDefault: () => {}, currentTarget: btn
    }), navigate))
    document.body.replaceChildren(el)
    function navigate (event) {
      event.preventDefault()
      const btn = event.currentTarget
      const { name } = btn.dataset
      const [icon] = btn.children
      const is_idle = state.program[name] === 'idle'
      icon.textContent = is_idle ? icon_stop : icon_play
      state.program[name] = is_idle ? 'busy' : 'idle'
      if (!is_idle) {
        state.program[name] = 'idle'
        grid.querySelector(`#${name}`).remove()
        return
      }
      const app = Object.assign(document.createElement('div'), { id: name })
      const randomHsl = () => `hsla(${Math.random() * 360}, 100%, 65%, 1)`
      const c = randomHsl()
      app.style = `box-sizing: border-box; padding: 2px; flex-grow: 1; background-color: ${c};`
      // setInterval(() => { app.style.backgroundColor = randomHsl() }, 50);
      const shadow = app.attachShadow({ mode: 'closed' })
      shadow.append(spawn(name, command[name], port => {
        port.onmessage = onmessage
        tasks[name] = port
      }))
      function onmessage ({ data, ports: [port] }) {
        console.log(`%c[(vault)]%c[by ${name.toUpperCase()}] recv`, 'color:green;', 'color:white;', data, port)
        console.log('@TODO: set up interaction')
      }
      grid.append(app)
    }
  }
  // ----------------------------------------------------------------------------
})()