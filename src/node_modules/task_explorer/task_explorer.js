// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
//  ----------------------------------------
const sheet = new CSSStyleSheet()
sheet.replaceSync(get_theme())
const shopts = { mode: 'closed' }
//  ----------------------------------------
module.exports = task_explorer
//  ----------------------------------------
function task_explorer (opts, protocol) {
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const id = `${ID}:${count++}` // assigns their own name
  const status = {}
  const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {} } // all state of component instance
  const { host } = opts
  const json_data = JSON.parse(JSON.stringify(require('./data.json')))
  const name = 'task_explorer'
  let selected_task
  let chat_task, result, track
  let code_words = {inputs: 'io', outputs: 'io', tasks: 'task'}
  // ----------------------------------------
  // PROTOCOL
  // ----------------------------------------
  const on = { 
    'on_add_node': on_add_node,
    'handle_add': handle_add,
    'send': send,
    'post_msg': post_msg,
    'handle_invite': handle_invite,
    'on_invite': on_invite,
    'handle_export': handle_export
  }
  const channel_up = use_protocol('up')({ protocol, state, on })

  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div');
  const shadow = el.attachShadow(shopts)
  shadow.adoptedStyleSheets = [sheet]
  shadow.innerHTML = `
    <main>
    </main>`
  // ----------------------------------------
  const tree_el = shadow.querySelector('main')
  // ----------------------------------------
  // INIT
  // ----------------------------------------
  fill_tree_el()
  return el

  async function fill_tree_el () {
    tree_el.innerHTML = ''
    tree_el.append(...json_data.filter(data => data.root).map(add_node_el))
  }
  function add_node_el (data) {
    const element = document.createElement('div')
    element.classList.add(data.type, 'node')
    element.tabIndex = '0'
    element.id = 'a'+data.id
    element.innerHTML = `
      <div class="inputs nodes">
      </div>
      <div class="task_name">
        <div class="before"></div>
        <div class="emoji"></div>
        ${data.name}
        <div class="after">ðŸ”—</div>
      </div>
      <div class="outputs nodes">
      </div>
      <div class="tasks nodes">
      </div>
    `

    const before = element.querySelector('.task_name > .before')
    const after = element.querySelector('.task_name > .after')
    const outputs = element.querySelector('.outputs')
    const inputs = element.querySelector('.inputs')
    const tasks = element.querySelector('.tasks')
    before.onclick = () => {
      element.classList.toggle('show')
      if(data.outputs && outputs.children.length < 1){
        for(const i of data.outputs)
          outputs.append(add_node_el(json_data[i]))
        outputs.classList.add('padding')
      }
      if(data.tasks && tasks.children.length < 1){
        for(const i of data.tasks)
          tasks.append(data.type === 'io' ? add_node_link(json_data[i]) : add_node_el(json_data[i]))
        tasks.classList.add('padding')
        outputs.classList.add('border')
      }
      if(data.inputs && inputs.children.length < 1){
        for(const i of data.inputs)
          inputs.append(add_node_el(json_data[i]))
        inputs.classList.add('padding')
      }
    }
    element.onfocus = () => {
      selected_task = element
      selected_task.addEventListener('blur', e => {
        if(e.relatedTarget && e.relatedTarget.classList.contains('noblur'))
          return
        selected_task = undefined
      })
    }
    element.ondblclick = open_chat
    after.onclick = () => {
      alert(host+'-'+data.id)
      try{
        navigator.clipboard.writeText(host+'-'+data.id) 
      }
      catch{

      }
    }
    return element
  }
  function add_node_link (data) {
    const element = document.createElement('div')
    element.classList.add('next', 'node')
    element.dataset.id = data.id
    element.innerHTML = `
      <div class="task_name">
        <div class="before"></div>
        ${data.name}
      </div>`
    element.onclick = jump
    
    return element
  }
  async function jump (e){
    let target_id = e.currentTarget.dataset.id
    const el = tree_el.querySelector('#a'+target_id)
    if(el)
      el.focus()
    else{
      let temp = json_data[target_id]
      const path = []
      while(!temp.root){
        path.push(temp.id)
        temp = json_data[temp.parent]
      }
      temp = tree_el.querySelector('#a'+temp.id)
      target_id = 'a'+target_id
      while(temp.id !== target_id){
        const before = temp.querySelector('.before')
        before.dispatchEvent(new MouseEvent('click', {bubbles:true, cancelable: true, view: window}))
        temp.classList.add('show')
        temp = temp.querySelector('#a'+path.pop())
      }
      temp.focus()
    }
      
  }
  async function traverse (id) {
    result = []
    track = []
    recurse(id)
    return result
  }
  function recurse (id){
    if(track.includes(id))
      return
    result.push(json_data[id])
    track.push(id)
    temp = 0
    while(json_data[id].tasks && temp < json_data[id].tasks.length){
      recurse(json_data[id].tasks[temp])
      temp++
    }
    temp = 0
    while(json_data[id].inputs && temp < json_data[id].inputs.length){
      recurse(json_data[id].inputs[temp])
      temp++
    }
    temp = 0
    while(json_data[id].outputs && temp < json_data[id].outputs.length){
      recurse(json_data[id].outputs[temp])
      temp++
    }
  }
  async function add_node_data (name, type, parent_id, users){
    const node_id = json_data.length
    json_data.push({ id: node_id, name, type: code_words[type], chat: [], users })
    if(parent_id){
      console.error(json_data[parent_id])
      !chat_task && json_data[parent_id].chat.push({username: 'system', content: 'Added '+name})
      const sub_nodes = json_data[parent_id][type]
      sub_nodes ? sub_nodes.push(node_id) : json_data[parent_id][type] = [node_id]
    }
    else{
      json_data[node_id].root = true
      json_data[node_id].users = [opts.host]
    }
  }
  async function on_add_node (data) {
    const node = data.id ? shadow.querySelector('#a' + data.id + ' > .'+data.type) : tree_el
    node.children.length > 0 && node.prepend(add_node_el({ name: data.name, id: json_data.length, type: code_words[data.type] }))
    add_node_data(data.name, data.type, data.id, data.users.push(host))
  }
  async function handle_export () {
    // const data = await traverse( selected_task.id.slice(1) )
    // const json_string = JSON.stringify(data, null, 2);
    // const blob = new Blob([json_string], { type: 'application/json' });
    // const link = document.createElement('a');
    // link.href = URL.createObjectURL(blob);
    // link.download = 'data.json';
    // link.click();

    alert(selected_task.innerText);
    navigator.clipboard.writeText(selected_task.innerText)
    .then(() => {
        // Cleanup
        window.getSelection().removeAllRanges();
        document.body.removeChild(tempElement);
        alert('HTML copied to clipboard');
    })
    .catch((err) => {
        console.error('Failed to copy HTML: ', err);
    });

  }
  async function handle_add ({ data }) {
    data = data.slice(2).trim().toLowerCase() + 's'
    const input = document.createElement('input')
    let node, task_id
    if(selected_task){
      node = selected_task.querySelector('.' + data)
      task_id = selected_task.id.slice(1)
      const before = selected_task.querySelector('.before')
      before.dispatchEvent(new MouseEvent('click', {bubbles:true, cancelable: true, view: window}))
      selected_task.classList.add('show')
    }
    else{
      node = tree_el
      task_id = ''
    }

    node.prepend(input)
    input.onkeydown = async (event) => {
      if (event.key === 'Enter') {
        node.firstElementChild.remove()
        node.prepend(add_node_el({ name: input.value, id: json_data.length, type: code_words[data] }))
        const users = task_id ? json_data[task_id].users : [host]
        add_node_data(input.value, data, task_id, users)
        if(task_id && json_data[task_id].users.length > 1)
          channel_up.send({
            head: [id, channel_up.send.id, channel_up.mid++],
            type: 'send',
            data: {to: 'task_explorer', route: ['up', 'task_explorer'], users: json_data[task_id].users.filter(user => user !== host), type: 'on_add_node', data: {name: input.value, id: task_id, type: data, users} }
          })
        if(chat_task && task_id === chat_task.id.slice(1))
          channel_up.send({
            head: [id, channel_up.send.id, channel_up.mid++],
            type: 'post_msg',
            data: {username: 'system', content: 'Added '+input.value}
          })
      }
    }
    input.focus()
  }
  async function send ({ data }) {
    const {to, route} = data
    if(to === name){
      const {type, data: shuttle_data} = data
      on[type](shuttle_data)
      return
    }
    const channel = state.net[state.aka[route[0]]]
    data.route = data.route.slice(1)
    channel.send({
      head: [id, channel.send.id, channel.mid++],
      type: 'send',
      data
    })
  }
  async function open_chat () {
    const node = json_data[Number(selected_task.id.slice(1))]
    channel_up.send({
      head: [id, channel_up.send.id, channel_up.mid++],
      type: 'open_chat',
      data: {chat_data: node.chat, chat_id: node.id}
    })
    
    if(chat_task)
      chat_task.classList.remove('chat_active')
    chat_task = selected_task
    chat_task.classList.add('chat_active')
  }
  async function post_msg ({ data }) {
    const node = json_data[Number(data.chat_id)]
    console.error(node)
    node.chat.push({ username: data.username, content: data.content })
  }
  async function handle_invite ({ sender, task_id }) {
    const node = json_data[Number(task_id)]
    console.error(task_id, json_data)
    node.users.push(sender)
    channel_up.send({
      head: [id, channel_up.send.id, channel_up.mid++],
      type: 'send',
      data: {to: 'task_explorer', route: ['up', 'task_explorer'], users: [sender], type: 'on_invite', data: node }
    })
  }
  async function on_invite (data) {
    const {name, id, type} = data
    tree_el.prepend(add_node_el({ name, id, type }))
    json_data.push(data)
  }
}

function get_theme () {
  return `
  main{
    max-height: 300px;
    overflow-y: scroll;
  }
  .task{
    cursor: pointer;
    margin: 5px 0;
    margin-left: 10px;
  }
  .task_name > .emoji{
    display: inline;
    margin-left: -4px;
  }
  .node > .task_name > .emoji::before{
    content: 'â”€ðŸ“­';
  }
  .node > .task_name::before{
    content: 'â”œâž•';
  }
  :not(.inputs) > .node:last-child > .task_name::before{
    content: 'â””âž•';
  }
  .node.show > .task_name::before{
    content: 'â”œâž–';
  }
  :not(.inputs) > .node.show:last-child > .task_name::before{
    content: 'â””âž–';
  }
  .next > .task_name::before {
    content: 'â”œðŸ–‡ï¸â”€';
  }
  .next:last-child > .task_name::before {
    content: 'â””ðŸ–‡ï¸â”€';
  }
  .node > .nodes{
    display: none;
    margin: 5px 0;
    padding-left: 5px;
    margin-left: 0;
    border-left: 1px solid white;
    position: relative;
  }
  .node:last-child > .tasks,
  .node:last-child > .outputs{
    border-color: transparent;
  }

  .task .task_name{
    margin-left: -5px;
  }
   .input.padding:first-child,
   .tasks.padding:first-child{
    padding-top: 5px;
  }
   .output.padding:last-child,
   .tasks.padding:last-child{
    padding-bottom: 5px
  }
  .inputs > .io > .task_name > .emoji::before{
    content: 'â”€ðŸ“¥';
  }
  .outputs > .io > .task_name > .emoji::before{
    content: 'â”€ðŸ“¤';
  }
  .inputs > .node:first-child > .task_name::before{
    content: 'â”Œâž•';
  }
  .inputs.show > .node:first-child > .task_name::before{
    content: 'â”Œâž–';
  }
  .task_name{
    position: relative;
  }
  .task_name > .before{
    display: inline;
    position: absolute;
    left: 0;
    width: 43px;
    height: 18px;
  }
  .task_name > .after{
    display: inline;
  }
   .io{
    padding-left: 15px;
    margin-left: 10px;
  }
  .outputs.border > .io{
    border-left: 1px solid white;
  }
  .task:focus{
    background-color: #222;
  }
  .task.chat_active > .task_name::after{
    content: '';
    background-color: green;
    border-radius: 100%;
    width: 10px;
    height: 10px;
    display: inline-block;
  }
  .node.show > .nodes{
    display: block;
  }
  `
}
function use_protocol (petname) {
  return ({ protocol, state, on = { } }) => {
    if (petname in state.aka) throw new Error('petname already initialized')
    const { id } = state
    const invalid = on[''] || (message => console.error('invalid type', message))
    if (protocol) return handshake(protocol(Object.assign(listen, { id })))
    else return handshake
    // ----------------------------------------
    // @TODO: how to disconnect channel
    // ----------------------------------------
    function handshake (send) {
      state.aka[petname] = send.id
      const channel = state.net[send.id] = { petname, mid: 0, send, on }
      return protocol ? channel : Object.assign(listen, { id })
    }
    function listen (message) {
      const [from] = message.head
      const by = state.aka[petname]
      if (from !== by) return invalid(message) // @TODO: maybe forward
      console.log(`[${id}]:${petname}>`, message)
      const { on } = state.net[by]
      const action = on[message.type] || invalid
      action(message)
    }
  }
}
