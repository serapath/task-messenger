const taskdb = require('taskdb')
// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
//  ----------------------------------------
const sheet = new CSSStyleSheet()
sheet.replaceSync(get_theme())
const shopts = { mode: 'closed' }
//  ----------------------------------------
module.exports = task_explorer
//  ----------------------------------------
function task_explorer (opts, protocol) {
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const id = `${ID}:${count++}` // assigns their own name
  const status = {}
  const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {} } // all state of component instance
  const { host } = opts
  const name = 'task_explorer'
  const code_words = {inputs: 'io', outputs: 'io', tasks: 'task'}
  const add_words = {tasks: 'hub'}
  // ----------------------------------------
  // PROTOCOL
  // ----------------------------------------
  const on = { 
    'on_add_node': on_add_node,
    'handle_add': handle_add,
    'send': send,
    'post_msg': post_msg,
    'handle_invite': handle_invite,
    'on_invite': on_invite,
    'handle_export': handle_export
  }
  const on_add = {
    'input': add_node_io,
    'output': add_node_io,
    'link': add_node_link,
    'task': add_node_sub,
  }
  const channel_up = use_protocol('up')({ protocol, state, on })

  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div');
  const shadow = el.attachShadow(shopts)
  shadow.adoptedStyleSheets = [sheet]
  shadow.innerHTML = `
    <div class="box">
      <main>
      </main>
      <div class="popup" tabindex="0">
        <div>Edit</div>
        <div>Drop</div>
      </div>
      <style>
      </style>
    </div>
    `
  // ----------------------------------------
  const tree_el = shadow.querySelector('main')
  const popup = shadow.querySelector('.popup')
  const styles = shadow.querySelector('style')
  // ----------------------------------------
  // ELEMENTS
  // ----------------------------------------
  {
    const on = { 
      'set': set
    }
    const protocol = use_protocol('taskdb')({ state, on })
    const opts = {host}
    taskdb(opts, protocol)
    async function set ({ data }) {
      state.query_result = data
    }
  }
  // ----------------------------------------
  // INIT
  // ----------------------------------------
  let json_data
  const channel = state.net[state.aka.taskdb]
  channel.send({
    head: [id, channel.send.id, channel.mid++],
    type: 'get',
    data: '/'
  })
  if(state.query_result){
    json_data = state.query_result
    fill_tree_el()
  }
  else
    fetch("./data_"+host+".json")
    .then(res => res.json())
    .then(data => {
        json_data = data
        fill_tree_el()
        channel.send({
          head: [id, channel.send.id, channel.mid++],
          type: 'set',
          data: json_data
        })
      }
    )
  
  return el

  async function fill_tree_el () {
    const root_nodes = json_data.filter(data => data.root)
    const length = root_nodes.length - 1
    root_nodes.forEach((data, i) => tree_el.append(...add_node_root({ data, last: i === length })))
  }
  function create_node (type, id, classes) {
    const element = document.createElement('div')
    element.classList.add(type, 'node', ...classes)
    element.tabIndex = '0'
    element.id = 'a'+id
    return element
  }
  /******************************************
   Addition Operation
  ******************************************/
  function add_node_el ({ data, parent, space, super_last, type, classes }){
    const is_single = parent.children.length ? false : true
    if(data.root){
      parent.prepend(...add_node_root({ data, last: false}))
      return
    }
    console.error(type)
    if(type === 'inputs')
      parent.append(...on_add[type]({ data, space, super_last, first: is_single, classes}))
    else
      parent.after(...on_add[type]({ data, space, super_last, last: is_single, classes}))

  }
  function add_node_root ({ data, last }) {
    const element = create_node(data.type, data.id, [])
    const space = ''
    element.dataset.space = space
    element.dataset.super_last = last ? 'a' : ''

    element.innerHTML = `
      <div class="task_name">
        ${last ? 'â””' : 'â”œ'}<span class="tas">ðŸ““â”€</span>${data.name}<span class="last">...</span>
      </div>
    `
    const sub_emo = element.querySelector('.task_name > .tas')
    const last_el = element.querySelector('.task_name > .last')
    const sub_div = document.createElement('div')
    sub_div.classList.add('sub_div')

    let sub_open
    sub_emo.onclick = () => {
      if(sub_open){
        sub_emo.innerHTML = 'ðŸ““â”€'
      } else{
        sub_emo.innerHTML = 'ðŸ“–â”¬'
      }
      sub_open = handle_click({ el: sub_div, type: 'task', data: data.sub, space, is_open: sub_open, super_last: last, pos: false, classes: '', parent_id: data.id })
    }
    element.onfocus = handle_focus
    last_el.onclick = handle_popup
    return [element, sub_div]
  }
  function add_node_sub ({ data, last, super_last, space, classes }) {
    const element = create_node(data.type, data.id, classes)
    if(!data.root)
      space += super_last ? '&emsp;&emsp;' : 'â”‚&emsp;&nbsp;'
    element.dataset.space = space
    element.dataset.super_last = last ? 'a' : ''
    element.innerHTML = `
      <div class="task_name">
        ${space}${last ? 'â””' : 'â”œ'}<span class="hub">ðŸ“ª</span><span class="tas">â”€ðŸ“ª</span><span class="inp">ðŸ—ƒ</span><span class="out">â”€ðŸ—ƒ</span><span class="name">${data.name}</span><span class="last">...</span>
      </div>
    `
    const task_name = element.querySelector('.task_name > .name')
    const hub = element.querySelector('.task_name > .hub')
    const sub = element.querySelector('.task_name > .tas')
    const inp = element.querySelector('.task_name > .inp')
    const out = element.querySelector('.task_name > .out')
    const last_el = element.querySelector('.task_name > .last')
    // const after = element.querySelector('.task_name > .after')
    const hub_div = document.createElement('div')
    hub_div.classList.add('hub_div'+data.id)
    const outputs_div = document.createElement('div')
    outputs_div.classList.add('outputs_div'+data.id)
    const sub_div = document.createElement('div')
    sub_div.classList.add('sub_div'+data.id)
    
    let hub_open, sub_open, inp_open, out_open
    hub.onclick = () => {
      if(hub_open){
        styles.innerHTML += `
        .link.input${data.id}{
          display: inline;
        }
        .not.link.input${data.id}{
          display: none;
        }`
        hub.innerHTML = 'ðŸ“ª'
        sub_open ? sub.innerHTML = 'â”¬'+sub.innerHTML.slice(1) : sub.innerHTML = 'â”€'+sub.innerHTML.slice(1)
      } else{
        styles.innerHTML += `
        .link.input${data.id}{
          display: none;
        }
        .not.link.input${data.id}{
          display: inline;

        }`
        hub.innerHTML = 'ðŸ“­'
        sub_open ? sub.innerHTML = 'â”¼'+sub.innerHTML.slice(1) : sub.innerHTML = 'â”´'+sub.innerHTML.slice(1)
      }
      hub_open = handle_click({ el: hub, type: 'link', data: data.hub, space, is_open: hub_open, pos: true, classes: classes, parent_id: data.id, super_last: last })
    }
    sub.onclick = () => {
      if(sub_open){
        styles.innerHTML += `
        .link.output${data.id}{
          display: inline;
        }
        .not.link.output${data.id}{
          display: none;
        }`
        hub_open ? sub.innerHTML = 'â”´ðŸ“ª' : sub.innerHTML = 'â”€ðŸ“ª'
      } else{
        styles.innerHTML += `
        .link.output${data.id}{
          display: none;
        }
        .not.link.output${data.id}{
          display: inline;

        }`
        hub_open ? sub.innerHTML = 'â”¼ðŸ“­' : sub.innerHTML = 'â”¬ðŸ“­'
      }
      sub_open = handle_click({ el: sub_div, type: 'task', data: data.sub, space, is_open: sub_open, super_last: last, pos: false, classes: classes, parent_id: data.id })
    }
    inp.onclick = () => {
      if(inp_open){
        inp.innerHTML = 'ðŸ—ƒ'
        out_open ? out.innerHTML = 'â”¬'+out.innerHTML.slice(1) : out.innerHTML = 'â”€'+out.innerHTML.slice(1)
      } else{
        inp.innerHTML = 'ðŸ—‚'
        out_open ? out.innerHTML = 'â”¼'+out.innerHTML.slice(1) : out.innerHTML = 'â”´'+out.innerHTML.slice(1)
      }
      const space_copy = space + `â”‚&emsp;<span class="not link input${data.id}">&nbsp;â”‚</span><span class="link input${data.id}">&emsp;</span>&emsp;&emsp;&ensp;`
      inp_open = handle_click({ el: element, type: 'input', data: data.inputs, space: space_copy, is_open: inp_open, pos: true, classes: classes, parent_id: data.id })
    }
    out.onclick = () => {
      if(out_open){
        inp_open ? out.innerHTML = 'â”´ðŸ—ƒ' : out.innerHTML = 'â”€ðŸ—ƒ'
      } else{
        inp_open ? out.innerHTML = 'â”¼ðŸ—‚' : out.innerHTML = 'â”¬ðŸ—‚'
      }
      const space_copy = space + `${last ? '&ensp;&nbsp;' : 'â”‚'}&emsp;<span class="not link output${data.id}">&nbsp;â”‚</span><span class="link output${data.id}">&emsp;</span>&emsp;&emsp;&ensp;`
      out_open = handle_click({ el: outputs, type: 'output', data: data.outputs, space: space_copy, is_open: out_open, pos: false, classes: classes, parent_id: data.id })
    }
    element.onfocus = handle_focus
    task_name.onclick = open_chat
    last_el.onclick = handle_popup
    // after.onclick = () => {
    //   alert(host+'-'+data.id)
    //   try{
    //     navigator.clipboard.writeText(host+'-'+data.id) 
    //   }
    //   catch{

    //   }
    // }
    return [hub_div, element, outputs_div, sub_div]
  }
  function add_node_io ({ data, first, last, space, classes }) {
    const element = create_node(data.type, data.id, classes)
    element.innerHTML = `
    <div class="task_name">
     ${space}${first ? 'â”Œ' : last ? 'â””' : 'â”œ'}</span><span class="btn">ðŸ“¥â”€</span>${data.name}<span class="after">ðŸ”—</span>
    </div>`
    const btn = element.querySelector('.task_name > .btn')
    const tasks = document.createElement('div')
    let is_open
    btn.onclick = () => is_open = handle_click({ el: tasks, type: 'link', data: data.sub, space, is_open, pos: false, classes, parent_id: data.id, super_last: last })
    return [element, tasks]
  }
  function add_node_link ({ data, first, last, space, classes, super_last }) {
    const element = document.createElement('div')
    element.classList.add('link', 'node', ...classes)
    element.dataset.id = data.id
    space += super_last ? '&emsp;&emsp;' : 'â”‚&emsp;&nbsp;'
    element.innerHTML = `
      <div class="task_name">
        ${space}${last ? 'â””' : first ? 'â”Œ' : 'â”œ'} ${data.name}
      </div>`
    element.onclick = jump
    
    return [element]
  }
  async function add_node_data (name, type, parent_id, users){
    const node_id = json_data.length
    json_data.push({ id: node_id, name, type: code_words[type], chat: [], users })
    if(parent_id){
      state.chat_task && json_data[parent_id].chat.push({username: 'system', content: host+' added '+type.slice(0,-1)+': '+name})
      const sub_nodes = json_data[parent_id][type]
      sub_nodes ? sub_nodes.push(node_id) : json_data[parent_id][type] = [node_id]
    }
    else{
      json_data[node_id].root = true
      json_data[node_id].users = [opts.host]
    }
    const channel = state.net[state.aka.taskdb]
    channel.send({
      head: [id, channel.send.id, channel.mid++],
      type: 'set',
      data: json_data
    })
  }
  async function on_add_node (data) {
    const node = data.id ? shadow.querySelector('#a' + data.id + ' > .'+data.type) : tree_el
    node.children.length && add_node_el({ data: { name: data.name, id: json_data.length, type: code_words[data.type] }, parent: node, super_last: data.super_last, type: data.type, space: data.space })
    add_node_data(data.name, data.type, data.id, data.users.push(host))
  }
  /******************************************
   Event handlers
  ******************************************/
  function handle_focus (e) {
    state.xtask = e.target
    state.xtask.classList.add('focus')
    state.xtask.addEventListener('blur', e => {
      if(e.relatedTarget && e.relatedTarget.classList.contains('noblur'))
        return
      console.error(e.relatedTarget)
      state.xtask.classList.remove('focus')
      state.xtask = undefined
    }, { once: true })
  }
  function handle_popup (e) {
    const el = e.target
    el.classList.add('show')
    popup.style.top = el.offsetTop - 20 + 'px'
    popup.style.left = el.offsetLeft - 56 + 'px'
    popup.focus()
    popup.addEventListener('blur', () => {
      el.classList.remove('show')
    }, { once: true })
  }
  function handle_click ({ el, type, data, space, is_open, super_last, pos, classes, parent_id }) {
    classes = [...classes, type+parent_id]
    if(data){
      const selector = '.'+type+parent_id
      //hide subnodes
      if(is_open)
        styles.innerHTML += `
          ${selector}{
            display: none;
          }
        `
      //show subnodes
      else if(tree_el.querySelector(selector))
        styles.innerHTML += `
          ${selector}{
            display: block;
          }
        `
      //make subnodes
      else{
        length = data.length - 1
        data.forEach((value, i) => el.before(...on_add[type]({ data: json_data[value], first: pos ? 0 === i : false, last: pos ? false : length === i, space, super_last, classes })))
      }
    }
    return !is_open
  }
  async function handle_export () {
    const data = await traverse( state.xtask.id.slice(1) )
    const json_string = JSON.stringify(data, null, 2);
    const blob = new Blob([json_string], { type: 'application/json' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'data.json';
    link.click();
  }
  async function handle_add (data) {
    data = data.slice(2).trim().toLowerCase()
    const input = document.createElement('input')
    let node, classes, task_id, space = '', super_last = true, root = true
    if(state.xtask){
      task_id = state.xtask.id.slice(1)
      classes = Array(...state.xtask.classList)
      classes.pop()
      node = state.xtask
      console.error(data + task_id)
      const before = state.xtask.querySelector('.' + data.slice(0,3))
      before.dispatchEvent(new MouseEvent('click', {bubbles:true, cancelable: true, view: window}))
      super_last = state.xtask.dataset.super_last
      space = state.xtask.dataset.space
      state.xtask.classList.remove('focus')
      state.xtask = undefined
      root = false
      node.after(input)
    }
    else{
      node = tree_el
      task_id = ''
      node.prepend(input)
    }
    input.onkeydown = async (event) => {
      if (event.key === 'Enter') {
        input.blur()
        add_node_el({ data : { name: input.value, id: json_data.length, type: code_words[data], root }, space, super_last, type: data, parent: node, classes })
        const users = task_id ? json_data[task_id].users : [host]
        add_node_data(input.value, data, task_id, users)
        if(users.length > 1)
          channel_up.send({
            head: [id, channel_up.send.id, channel_up.mid++],
            type: 'send',
            data: {to: 'task_explorer', route: ['up', 'task_explorer'], users: json_data[task_id].users.filter(user => user !== host), type: 'on_add_node', data: {name: input.value, id: task_id, type: data, users, super_last, space} }
          })
        if(state.chat_task && task_id === state.chat_task.id.slice(1))
          channel_up.send({
            head: [id, channel_up.send.id, channel_up.mid++],
            type: 'post_msg',
            data: {username: 'system', content: host+' added '+data.slice(0, -1)+': '+input.value}
          })
      }
    }
    input.focus()
    input.onblur = () => input.remove()
  }
  /******************************************
   Tree traversal
  ******************************************/
  async function jump (e){
    let target_id = e.currentTarget.dataset.id
    const el = tree_el.querySelector('#a'+target_id)
    if(el)
      el.focus()
    else{
      const path = []
      for(let temp = json_data[target_id]; !temp.root; temp = json_data[temp.parent])
        path.push(temp.id)
      temp = tree_el.querySelector('#a'+temp.id)
      target_id = 'a'+target_id
      while(temp.id !== target_id){
        const before = temp.querySelector('.before')
        before.dispatchEvent(new MouseEvent('click', {bubbles:true, cancelable: true, view: window}))
        temp.classList.add('show')
        temp = temp.querySelector('#a'+path.pop())
      }
      temp.focus()
    }
      
  }
  async function traverse (id) {
    state.result = []
    state.track = []
    recurse(id)
    return state.result
  }
  function recurse (id){
    if(state.track.includes(id))
      return
    state.result.push(json_data[id])
    state.track.push(id)
    for(temp = 0; json_data[id].tasks && temp < json_data[id].tasks.length; temp++)
      recurse(json_data[id].tasks[temp])
    for(temp = 0; json_data[id].inputs && temp < json_data[id].inputs.length; temp++)
      recurse(json_data[id].inputs[temp])
    for(temp = 0; json_data[id].outputs && temp < json_data[id].outputs.length; temp++)
      recurse(json_data[id].outputs[temp])
  }
  /******************************************
   Communication
  ******************************************/
  async function send ({ data }) {
    const {to, route} = data
    if(to === name){
      const {type, data: shuttle_data} = data
      on[type](shuttle_data)
      return
    }
    const channel = state.net[state.aka[route[0]]]
    data.route = data.route.slice(1)
    channel.send({
      head: [id, channel.send.id, channel.mid++],
      type: 'send',
      data
    })
  }
  async function open_chat () {
    const node = json_data[Number(state.xtask.id.slice(1))]
    channel_up.send({
      head: [id, channel_up.send.id, channel_up.mid++],
      type: 'open_chat',
      data: node
    })
    
    if(state.chat_task)
      state.chat_task.classList.remove('chat_active')
    state.chat_task = state.xtask
    state.chat_task.classList.add('chat_active')
  }
  async function post_msg ({ data }) {
    const node = json_data[Number(data.chat_id)]
    node.chat.push({ username: data.username, content: data.content })
  }
  async function handle_invite ({ sender, task_id }) {
    const node = json_data[Number(task_id)]
    node.users.push(sender)
    channel_up.send({
      head: [id, channel_up.send.id, channel_up.mid++],
      type: 'send',
      data: {to: 'task_explorer', route: ['up', 'task_explorer'], users: [sender], type: 'on_invite', data: node }
    })
  }
  async function on_invite (data) {
    const {name, id, type} = data
    tree_el.prepend(add_node_sub({ name, id, type }))
    json_data.push(data)
  }
}

function get_theme () {
  return `
  .box{
    position: relative;
  }
  main{
    max-height: 300px;
    overflow: scroll;
    max-width: 5px;
    min-width: 100%;
  }
  main > .task{
    position: relative;
    min-width: fit-content;
  }
  .node{
    cursor: pointer;
    margin: 5px 0;
  }
  .node > .nodes{
    display: none;
    margin: 5px 0;
  }
  .nodes.show{
    display: block;
  }
  .node.focus > .task_name{
    background-color: #222;
  }
  .io > .task_name > .space_sup{
    display: none;
  }
  .task_name{
    white-space: nowrap;
    width: 100%;
  }
  .task_name > .last{
    display: none;
    position: absolute;
    right: 3px;
    padding: 0 2px;
    background-color: black;
    color: white;
    box-shadow: 0 0 20px 1px rgba(255, 255, 255, 0.5);
  }
  .task_name:hover > .last,
  .task_name > .last.show{
    display: inline;
  }
  .task.chat_active > .task_name{
    color: green;
  }
  .popup{
    height: 0;
    position: absolute;
    background-color: #222;
    z-index: 1;
    overflow: hidden;
    cursor: pointer;
  }
  .popup:focus{
    height: auto;
    box-shadow: 0 0 2px 1px rgb(255, 255, 255);
  }
  .popup > div{
    padding: 5px 10px;
  }
  .popup > div:hover{
    background-color: #555;
  }
  .not{
    display: none;
  }
  `
}
function use_protocol (petname) {
  return ({ protocol, state, on = { } }) => {
    if (petname in state.aka) throw new Error('petname already initialized')
    const { id } = state
    const invalid = on[''] || (message => console.error('invalid type', message))
    if (protocol) return handshake(protocol(Object.assign(listen, { id })))
    else return handshake
    // ----------------------------------------
    // @TODO: how to disconnect channel
    // ----------------------------------------
    function handshake (send) {
      state.aka[petname] = send.id
      const channel = state.net[send.id] = { petname, mid: 0, send, on }
      return protocol ? channel : Object.assign(listen, { id })
    }
    function listen (message) {
      const [from] = message.head
      const by = state.aka[petname]
      if (from !== by) return invalid(message) // @TODO: maybe forward
      console.log(`[${id}]:${petname}>`, message)
      const { on } = state.net[by]
      const action = on[message.type] || invalid
      action(message)
    }
  }
}
