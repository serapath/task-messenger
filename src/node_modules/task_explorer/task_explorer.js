// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
//  ----------------------------------------
const sheet = new CSSStyleSheet()
sheet.replaceSync(get_theme())
const shopts = { mode: 'closed' }
//  ----------------------------------------
module.exports = task_explorer
//  ----------------------------------------
async function task_explorer (opts, protocol) {
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const id = `${ID}:${count++}` // assigns their own name
  const status = {}
  const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {} } // all state of component instance
  const {json_data, users} = opts
  const name = 'task_explorer'
  let selected_task
  let chat_task
  // ----------------------------------------
  // PROTOCOL
  // ----------------------------------------
  const on = { 
    'on_add_task': on_add_task,
    'handle_add': handle_add,
    'send': send,
    'get_chat': get_chat,
    'post_msg': post_msg
  }
  const channel_up = use_protocol('up')({ protocol, state, on })
  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div');
  const shadow = el.attachShadow(shopts)
  shadow.adoptedStyleSheets = [sheet]
  shadow.innerHTML = `
    <main>
    </main>`
  // ----------------------------------------
  const task_tree = shadow.querySelector('main')
  // ----------------------------------------
  // INIT
  // ----------------------------------------
  fill_task_tree()
  return el

  async function fill_task_tree () {
    task_tree.innerHTML = ''
    task_tree.append(...json_data.map(add_task))
  }
  function add_task (data) {
    const element = document.createElement('div')
    element.classList.add('task')
    element.tabIndex = '0'
    element.id = 'a'+data.id
    element.innerHTML = `
      <div class="inputs">
      </div>
      <div class="task_name">
        ${data.name}
      </div>
      <div class="children">
      </div>
      <div class="outputs">
      </div>
    `
    const task_name = element.querySelector('.task_name')
    task_name.onclick = () => {
      element.classList.toggle('show')
      selected_task = element
      selected_task.focus()
      selected_task.addEventListener('blur', e => {
        if(e.relatedTarget && e.relatedTarget.classList.contains('noblur'))
          return
        selected_task = undefined
      })
    }
    
    if(data.children){
      const children = element.querySelector('.children')
      children.append(...data.children.map(add_task))
      children.classList.add('padding')
    }
    if(data.inputs){
      const inputs = element.querySelector('.inputs')
      inputs.append(...data.inputs.map(add_io))
      inputs.classList.add('padding')
    }
    if(data.outputs){
      const outputs = element.querySelector('.outputs')
      outputs.append(...data.outputs.map(add_io))
      outputs.classList.add('padding')
    }
    return element
  }
  async function on_add_task ({ data }) {
    let tree_container
    if(data.id)
      tree_container = shadow.querySelector('#' + data.id).querySelector('.'+data.node_type)
    else
      tree_container = task_tree
    tree_container.prepend(await new_node(data.value, data.id, data.node_type))

  }
  function add_io (data) {
    const element = document.createElement('div')
    element.classList.add('io')
    element.innerHTML = data.name
    return element
  }
  async function handle_add ({ data }) {
    data = data.trim().toLowerCase() + 's'
    const input = document.createElement('input')
    let tree_container, task_id
    if(selected_task){
      tree_container = selected_task.querySelector('.' + data)
      task_id = selected_task.id
    }
    else{
      tree_container = task_tree
      task_id = ''
    }
    tree_container.prepend(input)
    input.onkeydown = async (event) => {
      if (event.key === 'Enter') {
        tree_container.firstElementChild.remove()
        tree_container.prepend(await new_node(input.value, task_id, data))
        channel_up.send({
          head: [id, channel_up.send.id, channel_up.mid++],
          type: 'send',
          data: {to: 'task_explorer', route: ['up', 'task_explorer'], users, type: 'on_add_task', data: {value: input.value, id: task_id, node_type: data} }
        })
      }
    }
    input.focus()
  }
  async function new_node (name, id, node_type) {
    const element = document.createElement('div')
    element.classList.add('io')
    element.tabIndex = '0'
    element.innerHTML = `${name}`

    const {tree, new_id} = await find_task(id, node_type)
    tree.push({id: ''+new_id, name, chat: [], children: []})
    element.id = 'a'+new_id
    
    return element
  }
  async function find_task (id, node_type, slice = true) {
    let tree = json_data
    let task, new_id
    if(slice)
      id = id.slice(1)
    id && id.split('-').forEach(i => {
      task = tree[Number(i)]
      tree = task.children
    })
    if(id.length > 1){
      new_id = id + '-' + tree.length
      tree = task[node_type]
    }
    else
      new_id = tree.length
    return {new_id, task, tree}
  }
  async function send ({ data }) {
    const {to, route} = data
    if(to === name){
      const {type, data} = data
      on[type](data)
      return
    }
    const channel = state.net[state.aka[route[0]]]
    data.route = data.route.slice(1)
    channel.send({
      head: [id, channel.send.id, channel.mid++],
      type: 'send',
      data
    })
  }
  async function get_chat (){
    const {task} = await find_task(selected_task.id, 'children')

    channel_up.send({
      head: [id, channel_up.send.id, channel_up.mid++],
      type: 'set_chat',
      data: {chat_data: task.chat, chat_id: task.id}
    })
    
    if(chat_task)
      chat_task.classList.remove('chat_focus')
    chat_task = selected_task
    chat_task.classList.add('chat_focus')
  }
  async function post_msg ({ data }){
    const {task} = await find_task(data.chat_id, 'children', false)
    task.chat.push({ username: data.username, content: data.content })
  }
}

function get_theme () {
  return `
  .task{
    cursor: pointer;
    margin: 5px 0;
    margin-left: 10px;
  }
  .task > .task_name::before{
    content: '\\251C \\2795 \\2500';
  }
  .task:last-child > .task_name::before{
    content: '\\2514 \\2795 \\2500';
  }
  .task.show > .task_name::before{
    content: '\\251C \\2796 \\2500';
  }
  .task.show:last-child > .task_name::before{
    content: '\\2514 \\2796 \\2500';
  }
  
  .task > .children,
  .task > .inputs,
  .task > .outputs{
    display: none;
    margin: 5px 0;
    padding-left: 5px;
    margin-left: 0;
    border-left: 1px solid white;
    position: relative;
  }
  .task:last-child > .children,
  .task:last-child > .outputs{
    border-color: transparent;
  }

  .task .task_name{
    margin-left: -5px;
  }
  .task > .inputs.padding:first-child,
  .task > .children.padding:first-child{
    padding-top: 5px;
  }
  .task > .outputs.padding:last-child,
  .task > .children.padding:last-child{
    padding-bottom: 5px
  }
  .task > .inputs .io::before{
    content: '\\251C \\1F4E5 \\2500';
  }
  .task > .inputs .io:first-child::before{
    content: '\\250C \\1F4E5 \\2500';
  }
  .task > .outputs .io::before{
    content: '\\251C \\1F4E4 \\2500';
  }
  .task > .outputs .io:last-child::before{
    content: '\\2514 \\1F4E4 \\2500';
  }
  .task .io{
    padding-left: 25px;
  }
  .task:focus{
    background-color: #222;
  }
  .task.chat_focus > .task_name::after{
    content: '';
    background-color: green;
    border-radius: 100%;
    width: 10px;
    height: 10px;
    display: inline-block;
  }
  .task.show > .children,
  .task.show > .inputs,
  .task.show > .outputs{
    display: block;
  }
  `
}
function use_protocol (petname) {
  return ({ protocol, state, on = { } }) => {
    if (petname in state.aka) throw new Error('petname already initialized')
    const { id } = state
    const invalid = on[''] || (message => console.error('invalid type', message))
    if (protocol) return handshake(protocol(Object.assign(listen, { id })))
    else return handshake
    // ----------------------------------------
    // @TODO: how to disconnect channel
    // ----------------------------------------
    function handshake (send) {
      state.aka[petname] = send.id
      const channel = state.net[send.id] = { petname, mid: 0, send, on }
      return protocol ? channel : Object.assign(listen, { id })
    }
    function listen (message) {
      const [from] = message.head
      const by = state.aka[petname]
      if (from !== by) return invalid(message) // @TODO: maybe forward
      console.log(`[${id}]:${petname}>`, message)
      const { on } = state.net[by]
      const action = on[message.type] || invalid
      action(message)
    }
  }
}
