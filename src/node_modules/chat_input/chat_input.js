// ----------------------------------------
// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
//  ----------------------------------------
const sheet = new CSSStyleSheet()
sheet.replaceSync(get_theme())
const shopts = { mode: 'closed' }
//  ----------------------------------------
module.exports = chat_input
//  ----------------------------------------
async function chat_input (opts, protocol) {
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const id = `${ID}:${count++}` // assigns their own name
  const status = {}
  const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {} } // all state of component instance
  const name = 'chat_input'
  state.shift_status = true
  state.textmode = "msg"
  state.username = opts.host

  // ----------------------------------------
  // PROTOCOL
  // ----------------------------------------
  const on = {
    activate_input
  }
  const channel_up = use_protocol('up')({ protocol, state, on })
  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div');
  el.classList.add('noblur')
  const shadow = el.attachShadow(shopts)
  shadow.adoptedStyleSheets = [sheet]
  shadow.innerHTML = `
    <div class="crud">
      <div class="btn_wrapper">
        <div class="popup" tabindex='0'>
          <div class="noblur">ðŸ“¥ Input </div>
          <div class="noblur">ðŸ“¤ Output </div>
          <div class="noblur">ðŸ“­ Task </div>
        </div>
        <button class="add noblur">
          +
        </button>
      </div>
      <button class="join noblur">
        join
      </button>
      <button class="export noblur">
        export
      </button>
      <div class="box">
        <div class="overlay">
          <div>/ðŸ—ƒlist <span>ðŸ“Œ</span></div>
          <div>/ðŸ“©text <span>ðŸ“Œ</span></div>
          <div>/ðŸ†•ðŸ”³task <span>ðŸ“Œ</span></div>
          <div>/ðŸ”³subtask <span>ðŸ“Œ</span></div>
          <div>/ðŸ“¨invite <span>ðŸ“Œ</span></div>
          <div>/ðŸ“¥input <span>ðŸ“Œ</span></div>
          <div>/ðŸ“¤output <span>ðŸ“Œ</span></div>
          <div>/ðŸ˜€emoji <span>ðŸ“Œ</span></div>
          <div>/ðŸ“Žattach file <span>ðŸ“Œ</span></div>
        </div>
        <textarea class="noblur" placeholder="Enter a command"></textarea>
      </div>
      <div class="send">></div>
    </div>`
  // ----------------------------------------
  const btn_add = shadow.querySelector('.add')
  const btn_join = shadow.querySelector('.join')
  const btn_export = shadow.querySelector('.export')
  const btn_send = shadow.querySelector('.send')
  const textarea = shadow.querySelector('textarea')
  const popup = shadow.querySelector('.popup')
  const overlay = shadow.querySelector('.overlay')
  // ----------------------------------------
  btn_add.onclick = () => popup.focus()
  btn_join.onclick = handle_join
  btn_export.onclick = handle_export
  btn_send.onclick = handle_send
  textarea.onkeyup = handle_keyup
  textarea.onkeydown = handle_keydown
  for (const child of popup.children){
    child.onclick = handle_add
  }
  
  // ----------------------------------------
  // INIT
  // ----------------------------------------
  return el

  /******************************************
   Event handlers
  ******************************************/
  async function handle_export () {
    const channel = state.net[state.aka.task_explorer]
    channel.send({
      head: [id, channel.send.id, channel.mid++],
      type: 'handle_export',
    })
  }
  async function handle_send () {
    if(textarea.disabled)
      return
    if(state.textmode === "msg")
      on_tx()
    else
      join()
  }
  async function handle_keydown (e) {
    if(state.shift_status)
      switch (e.key){
        case 'Enter':
          e.preventDefault()
          if(state.textmode === "msg")
            on_tx()
          else
            join()
          break
        case 'Shift':
          state.shift_status = false
      }
  }
  async function handle_add (e) {
    channel_up.send({
      head: [id, channel_up.send.id, channel_up.mid++],
      type: 'send',
      data: {to: 'task_explorer', route: ['task_explorer'], type: 'handle_add', data: e.target.innerHTML}
    })
  }
  async function handle_keyup (e) {
    e.target.style.height = "1px";
    e.target.style.height = (2+e.target.scrollHeight)+"px";
    if(e.key === 'Shift')
      state.shift_status = true
    if(textarea.value === '/'){
      overlay.classList.add('show')
      textarea.addEventListener('blur', handle_blur)
      textarea.addEventListener('focus', handle_blur)
    }
    else{
      overlay.classList.remove('show')
      textarea.removeEventListener('blur', handle_blur)
      textarea.removeEventListener('focus', handle_blur)
    }
  }
  async function handle_blur () {
    overlay.classList.toggle('show')
  }
  async function handle_join () {
    textarea.disabled = false
    textarea.placeholder = "Enter a invite code"
    state.textmode = 'join'
  }
  /******************************************
   Communication
  ******************************************/
  async function on_tx () {
    channel_up.send({
      head: [id, channel_up.send.id, channel_up.mid++],
      type: 'on_tx',
      data: {content: textarea.value.replaceAll('\n', '<br>'), username: state.username}
    })
    textarea.value = ''
  }
  async function join () {
    const [user, task_id] = textarea.value.split('-')
    channel_up.send({
      head: [id, channel_up.send.id, channel_up.mid++],
      type: 'send',
      data: {to: 'task_explorer', route: ['task_explorer'], users: [user], type: 'handle_invite', data: {sender: opts.host, task_id}}
    })
  }
  async function activate_input ({ data }) {
    textarea.disabled = false
    data ? textarea.placeholder = data : ''
  }
}
function get_theme () {
  return `
  *{
    box-sizing: border-box;
  }
  .crud{
    display: flex;
    gap: 10px;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    border: 1px solid gray;
  }
  .box{
    position: relative;
    margin: 40px 20px;
  }
  .box > textarea{
    height: 40px;
    min-height: 40px;
    padding: 10px;
    width: 100%;
  }
  .box > .overlay{
    display: none;
    position: absolute;
    background-color: #222;
    box-shadow: 0 0 2px 1px rgb(255, 255, 255);
    width: 100%;
    bottom: 50px;
  }
  .box > .overlay.show{
    display: block;
  }
  .box > .overlay > div{
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 4px 10px;
  }
  .box > .overlay > div:hover{
    background-color: #555;
  }
  textarea::-webkit-scrollbar{
    display: none;
  }
  .btn_wrapper{
    position: relative;
  }
  .btn_wrapper .popup{
    height: 0;
    position: absolute;
    bottom: 100%;
    background: black;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
  }
  .btn_wrapper .popup:focus{
    height: auto;
    padding: 5px;
    border: 1px solid gray;
  }
  .send{
    padding: 7px 10px;
    background-color: black;
    position: absolute;
    right: 40px;
    width: 30px;
    height: 30px;
    cursor: pointer;
    border-radius: 4px;
  }
  `
}
function use_protocol (petname) {
  return ({ protocol, state, on = { } }) => {
    if (petname in state.aka) throw new Error('petname already initialized')
    const { id } = state
    const invalid = on[''] || (message => console.error('invalid type', message))
    if (protocol) return handshake(protocol(Object.assign(listen, { id })))
    else return handshake
    // ----------------------------------------
    // @TODO: how to disjoin channel
    // ----------------------------------------
    function handshake (send) {
      state.aka[petname] = send.id
      const channel = state.net[send.id] = { petname, mid: 0, send, on }
      return protocol ? channel : Object.assign(listen, { id })
    }
    function listen (message) {
      const [from] = message.head
      const by = state.aka[petname]
      if (from !== by) return invalid(message) // @TODO: maybe forward
      console.log(`[${id}]:${petname}>`, message)
      const { on } = state.net[by]
      const action = on[message.type] || invalid
      action(message)
    }
  }
}
