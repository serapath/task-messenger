const cache = { }
const admin = { reset, on: null }
DB.admin = admin
module.exports = DB
function reset () { localStorage.clear() }
function DB (seed, hook) {
if (!seed || typeof seed !== 'string') throw new Error('no seed provided')
DB.admin = undefined
const pk = seed.slice(0, seed.length / 2)
const sk = seed.slice(seed.length / 2, seed.length)
if (cache[pk]) throw new Error(`seed "${seed}" already in use`)
const db = open(pk) || save(cache[pk] = { // internal audit book
  pk, sk, books: {}, names: {}, pages: [], state: {}, peers: []
})
db.pages.push({ type: 'load' })
make.on = on
return make
function on (debug) { hook = debug }
function make ({ name, key } = {}, _on) {
  const book = load({ name, key })
  key = book.pk
  const own = db.books[book.pk]
  const api = own ? { key, add, get, version, on } : { key, get, version, on }
  return book && api
  async function add (x) {
    const { length: i } = book.pages
    if (admin?.on?.(x, i, key, pk)) return
    if (hook?.(key, x, i)) return
    book.pages[i] = x
    save(book)
    book.peers.forEach(notify_reader)
    return i
    function notify_reader (port) {
      if (typeof port === 'function') port([x, i, key])
      else port.postMessage([x, i, key])
    }
  }
  async function get (i) { return book.pages[i] } // opts = { wait: false }
  async function version () { return book.pages.length - 1 }
  async function on (name, fn) {
    if (!fn) [name, fn] = ['add', name]
    if (typeof fn === 'function' || fn.postMessage) book.peers.push(fn)
    throw new Error('`fn` must be a function')
  }
}
function save (book) {
  localStorage[book.pk] = JSON.stringify(Object.assign({}, book, { peers: [] }))
  return book
}
function open (key) {
  return cache[key] ||= JSON.parse(localStorage[key] || null)
}
function load ({ name, key }) {
  if (sk === key || pk === key) throw new Error(`unauthorized access`)
  if (key) {
    const book = open(key)
    if (book && name) {
      if (!db.names[name]) (db.names[name] = key)
      else if (db.names[name] !== key) throw new Error(`name "${name}" is in use`)
    }
    return book
  } else if (name) {
    key = db.names[name]
    return key ? open(key) : init({name})
  } else throw new Error('must provide `name` and/or `key` to load book')
}
function init (name) {
  const [pk, sk] = [2, 2].map(x => `${Math.random()}`.slice(x))
  const book = save(cache[pk] = { pk, sk, pages: [], state: {}, peers: [] })
  db.names[name] = pk
  db.books[pk] = sk
  save(db)
  return book
}
}